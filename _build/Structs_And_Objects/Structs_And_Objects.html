---
redirect_from:
  - "/structs-and-objects/structs-and-objects"
interact_link: content/Structs_And_Objects/Structs_And_Objects.ipynb
kernel_name: julia-1.3
has_widgets: false
title: |-
  Structs and Objects
prev_page:
  url: /Strings_and_File_Processing/File_Processing.html
  title: |-
    File Processing
next_page:
  url: /Computational_Geometry/Chapter_Intro.html
  title: |-
    Computational Geometry
suffix: .ipynb

comment: "***PROGRAMMATICALLY GENERATED, DO NOT EDIT. SEE ORIGINAL FILES IN /content***"
---

    <main class="jupyter-page">
    <div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="Structs-and-Objects">Structs and Objects<a class="anchor-link" href="#Structs-and-Objects"> </a></h1><p>We have seen a number of different <em>types</em> in Julia, such as <code>Int64</code>, <code>Float64</code>, <code>Array{Float64,2}</code>, etc. Now we will learn how to create new types, how to use them to store data, and how to define new functions (methods) and operators on them. This is closely related to the concept of <em>object orientation</em> in other computer languages.</p>
<h2 id="Composite-types">Composite types<a class="anchor-link" href="#Composite-types"> </a></h2><p>The keyword <code>struct</code> is used to create a so-called composite type, that is, a new user-defined type.
The type is given a name, and a list of <em>fields</em> (or <em>attributes</em>) which are names that will be used
as variables to store data for objects of the new type.</p>
<p>As an example, we create a new type named <code>MyPoly</code> for storing and operating on polynomials.
The fields will be an array of coefficients <code>c</code>, and a character <code>var</code> to denote the name of the dependent
variable:</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-julia"><pre><span></span><span class="k">struct</span> <span class="n">MyPoly</span>
    <span class="n">c</span>
    <span class="n">var</span>
<span class="k">end</span>
</pre></div>

    </div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>The coefficients <code>c</code> will represent the polynomial in the standard monomial form:</p>
$$
p(x) = \sum_{k=0}^d c_{n-k}x^n
$$<p>where $c$ is the array of coefficients, $d$ is the polynomial degree, and $n$ is the length of the array $c$. Note that we allow for $n$ to be greater than the number of required coefficients $d+1$, and that the coefficients are stored in reverse order (that is, highest exponents come first).</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>With this definition, we can create a so-called <em>instance</em> of the type
(or <em>object</em>) by
providing the values for each of the fields. For example, the polynomial
$p(x) = 3x^2 - 5x + 2$ can be created as:</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-julia"><pre><span></span><span class="n">p</span> <span class="o">=</span> <span class="n">MyPoly</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="sc">&#39;x&#39;</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>MyPoly([3, -5, 2], &#39;x&#39;)</pre>
</div>

</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Note that by default, Julia will print the object using the type name and a list of the field values. Later we will override this and create a specialized output function.</p>
<p>You can define other ways to specify (or initialize) a polynomial using a so-called <em>constructor</em>,
which is a function that is called when a type is initiated. For example, if you want to allow for
a default value in the <code>var</code> field, you can add a constructor as shown below:</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-julia"><pre><span></span><span class="k">struct</span> <span class="n">MyPoly</span>
    <span class="n">c</span>
    <span class="n">var</span>
    <span class="n">MyPoly</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">var</span><span class="o">=</span><span class="sc">&#39;x&#39;</span><span class="p">)</span> <span class="o">=</span> <span class="n">new</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>
<span class="k">end</span>
</pre></div>

    </div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>At this point, the struct <code>p</code> does not do anything besides simply storing the variables <code>c</code> and <code>var</code>. They can be accessed using a <code>.</code> notation:</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-julia"><pre><span></span><span class="n">p</span><span class="o">.</span><span class="n">c</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>3-element Array{Int64,1}:
  3
 -5
  2</pre>
</div>

</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-julia"><pre><span></span><span class="n">p</span><span class="o">.</span><span class="n">var</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>&#39;x&#39;: ASCII/Unicode U+0078 (category Ll: Letter, lowercase)</pre>
</div>

</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>However, structs in Julia are <em>immutable</em> which means that once created, you can not change their contents. This is different from many other language, and there are some good reasons for this design. If you need to change the variables in a struct, or even add new fields, simply use the keyword <code>mutable struct</code> instead of <code>struct</code>. However, here we will stay with a standard struct, since in our example we will only modify the polynomials coefficients <code>c</code>. This is an exception which actually is allowed, since the variable <code>c</code> is itself a mutable object and its content can be changed.</p>
<p>For example, if you want to change the polynomial to $p(x) = -x^3 + 3x^2 - 5x + 2$ you can <em>not</em> change the actual array in <code>c</code>:</p>
<div class="highlight"><pre><span></span><span class="n">p</span><span class="o">.</span><span class="n">c</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>  <span class="c"># Error: Immutable struct</span>
</pre></div>
<p>but you can change the content in the existing array <code>c</code>:</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-julia"><pre><span></span><span class="n">resize!</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">c</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="n">p</span><span class="o">.</span><span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="o">:</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
<span class="n">p</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>MyPoly([-1, 3, -5, 2], &#39;x&#39;)</pre>
</div>

</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Of course, another option is to simply create a new instance of the <code>MyPoly</code> type:</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-julia"><pre><span></span><span class="n">p</span> <span class="o">=</span> <span class="n">MyPoly</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">p</span><span class="o">.</span><span class="n">var</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>MyPoly([-1, 3, -5, 2], &#39;x&#39;)</pre>
</div>

</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Functions-on-types">Functions on types<a class="anchor-link" href="#Functions-on-types"> </a></h2><p>We can easily define functions on new types, by passing the objects as arguments or return values.
For example, we can easily define a function that multiplies a polynomial $p(x)$ by $x$ in the
following way:</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-julia"><pre><span></span><span class="k">function</span> <span class="n">times_x</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
   <span class="k">return</span> <span class="n">MyPoly</span><span class="p">(</span><span class="n">vcat</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">c</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="n">p</span><span class="o">.</span><span class="n">var</span><span class="p">)</span> 
<span class="k">end</span>

<span class="n">times_x</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>MyPoly([-1, 3, -5, 2, 0], &#39;x&#39;)</pre>
</div>

</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>However, this functions only works if you pass a <code>MyPoly</code> type to it. In Julia you can write functions that operate differently on different types. A function which defines the behavior for a specific combination or number of arguments is called a <em>method</em>.</p>
<p>A function which is specialized for a certain type can be created using a <em>type declaration</em> with the <code>::</code> operator. As an example, we create a <code>degree</code> function to find the degree $d$. The implementation
is straight-forward, we simply search the for the first (highest degree) non-zero
coefficient. Note that we define the degree of the zero polynomial to zero.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-julia"><pre><span></span><span class="k">function</span> <span class="n">degree</span><span class="p">(</span><span class="n">p</span><span class="o">::</span><span class="n">MyPoly</span><span class="p">)</span>
    <span class="n">ix1</span> <span class="o">=</span> <span class="n">findfirst</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">c</span> <span class="o">.!=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ix1</span> <span class="o">==</span> <span class="nb">nothing</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="k">else</span>
        <span class="k">return</span> <span class="n">length</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">c</span><span class="p">)</span> <span class="o">-</span> <span class="n">ix1</span>
    <span class="k">end</span>
<span class="k">end</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>degree (generic function with 1 method)</pre>
</div>

</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-julia"><pre><span></span><span class="n">println</span><span class="p">(</span><span class="n">degree</span><span class="p">(</span><span class="n">MyPoly</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])))</span>
<span class="n">println</span><span class="p">(</span><span class="n">degree</span><span class="p">(</span><span class="n">MyPoly</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])))</span>
<span class="n">println</span><span class="p">(</span><span class="n">degree</span><span class="p">(</span><span class="n">MyPoly</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])))</span>
<span class="n">println</span><span class="p">(</span><span class="n">degree</span><span class="p">(</span><span class="n">MyPoly</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])))</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>0
0
1
4
</pre>
</div>
</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>By specializing the <code>degree</code> function to the <code>MyPoly</code> type, we can now use the same function name for other combinations or types, that is, to implement other methods. This is also called <em>overloading</em>.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-julia"><pre><span></span><span class="k">function</span> <span class="n">degree</span><span class="p">(</span><span class="n">p</span><span class="o">::</span><span class="kt">Int</span><span class="p">)</span>
    <span class="n">println</span><span class="p">(</span><span class="s">&quot;degree function called with Int argument&quot;</span><span class="p">)</span>
<span class="k">end</span>

<span class="k">function</span> <span class="n">degree</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="n">println</span><span class="p">(</span><span class="s">&quot;degree function called with any other argument&quot;</span><span class="p">)</span>
<span class="k">end</span>

<span class="n">degree</span><span class="p">(</span><span class="mf">1.234</span><span class="p">)</span>
<span class="n">degree</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="n">degree</span><span class="p">(</span><span class="o">-</span><span class="mi">123</span><span class="p">)</span>
<span class="n">degree</span><span class="p">(</span><span class="n">MyPoly</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]))</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>degree function called with any other argument
degree function called with any other argument
degree function called with Int argument
</pre>
</div>
</div>
</div>
<div class="jb_output_wrapper }}">
<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>2</pre>
</div>

</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Customized-printing">Customized printing<a class="anchor-link" href="#Customized-printing"> </a></h2><p>Julia provides a special function <code>show</code> in the <code>Base</code> package, which can be overloaded to change how objects of a new type are printed. For our polynomials, instead of showing the array of coefficients <code>c</code> and the name of the independent variable <code>var</code>, we will write it as a polynomial in standard math notation.</p>
<p>The details of this functions do not matter much, it mostly needs to deal with certain special cases to print polynomials correctly. The main point is that it will <em>only be called</em> for objects of type <code>MyPoly</code>.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-julia"><pre><span></span><span class="k">function</span> <span class="n">Base</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">io</span><span class="o">::</span><span class="kt">IO</span><span class="p">,</span> <span class="n">p</span><span class="o">::</span><span class="n">MyPoly</span><span class="p">)</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">degree</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="n">print</span><span class="p">(</span><span class="n">io</span><span class="p">,</span> <span class="s">&quot;MyPoly(&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">k</span> <span class="o">=</span> <span class="n">d</span><span class="o">:-</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span>
        <span class="n">coeff</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">c</span><span class="p">[</span><span class="k">end</span><span class="o">-</span><span class="n">k</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">coeff</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">d</span> <span class="o">&gt;</span> <span class="mi">0</span>
            <span class="k">continue</span>
        <span class="k">end</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">d</span>
            <span class="k">if</span> <span class="kp">isa</span><span class="p">(</span><span class="n">coeff</span><span class="p">,</span> <span class="kt">Real</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">coeff</span> <span class="o">&gt;</span> <span class="mi">0</span>
                    <span class="n">print</span><span class="p">(</span><span class="n">io</span><span class="p">,</span> <span class="s">&quot; + &quot;</span><span class="p">)</span>
                <span class="k">else</span>
                    <span class="n">print</span><span class="p">(</span><span class="n">io</span><span class="p">,</span> <span class="s">&quot; - &quot;</span><span class="p">)</span>
                <span class="k">end</span>
                <span class="n">coeff</span> <span class="o">=</span> <span class="n">abs</span><span class="p">(</span><span class="n">coeff</span><span class="p">)</span>
            <span class="k">else</span>
                <span class="n">print</span><span class="p">(</span><span class="n">io</span><span class="p">,</span> <span class="s">&quot; + &quot;</span><span class="p">)</span>
            <span class="k">end</span>
        <span class="k">end</span>
        <span class="k">if</span> <span class="kp">isa</span><span class="p">(</span><span class="n">coeff</span><span class="p">,</span> <span class="kt">Real</span><span class="p">)</span>
            <span class="n">print</span><span class="p">(</span><span class="n">io</span><span class="p">,</span> <span class="n">coeff</span><span class="p">)</span>
        <span class="k">else</span>
            <span class="n">print</span><span class="p">(</span><span class="n">io</span><span class="p">,</span> <span class="s">&quot;(</span><span class="si">$coeff</span><span class="s">)&quot;</span><span class="p">)</span>
        <span class="k">end</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">0</span>
            <span class="k">continue</span>
        <span class="k">end</span>
        <span class="n">print</span><span class="p">(</span><span class="n">io</span><span class="p">,</span> <span class="s">&quot;⋅&quot;</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">var</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="mi">1</span>
            <span class="n">print</span><span class="p">(</span><span class="n">io</span><span class="p">,</span> <span class="s">&quot;^&quot;</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
        <span class="k">end</span>
    <span class="k">end</span>
    <span class="n">print</span><span class="p">(</span><span class="n">io</span><span class="p">,</span> <span class="s">&quot;)&quot;</span><span class="p">)</span>
<span class="k">end</span>
</pre></div>

    </div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-julia"><pre><span></span><span class="n">p</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>MyPoly(-1⋅x^3 + 3⋅x^2 - 5⋅x + 2)</pre>
</div>

</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-julia"><pre><span></span><span class="n">MyPoly</span><span class="p">([</span><span class="o">-</span><span class="mf">1.234</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mf">4.321</span><span class="p">],</span> <span class="sc">&#39;s&#39;</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>MyPoly(-1.234⋅s^4 + 4.321)</pre>
</div>

</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Callable-objects">Callable objects<a class="anchor-link" href="#Callable-objects"> </a></h2><p>One basic operation to perform on a polynomial is evaluation, that is, for a given number $x$ compute $p(x)$. We will implement this using <em>Horner's rule</em>:</p>
$$
\begin{align}
p(x) &amp;= a_nx^n + a_{n-1} x^{n-1} + \cdots + a_0 \\
     &amp;= ((a_n + xa_{n-1})x + \cdots)x + a_0
\end{align}
$$<p>While we could implement this in a function with a new name, for example, <code>polyval</code>, Julia allows the definition of a method which behaves like a function evaluating the polynomial:</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-julia"><pre><span></span><span class="k">function</span> <span class="p">(</span><span class="n">p</span><span class="o">::</span><span class="n">MyPoly</span><span class="p">)(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">degree</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">c</span><span class="p">[</span><span class="k">end</span><span class="o">-</span><span class="n">d</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">cc</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">c</span><span class="p">[</span><span class="k">end</span><span class="o">-</span><span class="n">d</span><span class="o">+</span><span class="mi">1</span><span class="o">:</span><span class="k">end</span><span class="p">]</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">v</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">cc</span>
    <span class="k">end</span>
    <span class="k">return</span> <span class="n">v</span>
<span class="k">end</span>
</pre></div>

    </div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-julia"><pre><span></span><span class="n">println</span><span class="p">(</span><span class="n">p</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="n">println</span><span class="p">(</span><span class="n">p</span><span class="p">(</span><span class="mf">1.234</span><span class="p">))</span>
<span class="n">println</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mf">1.3</span><span class="p">]))</span>  <span class="c"># Note: Broadcasting automatically defined</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>-1
-1.4808129039999995
[-1.0, 32.0, -1.627]
</pre>
</div>
</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Plotting">Plotting<a class="anchor-link" href="#Plotting"> </a></h2><p>Using the evaluation functionality, we can easily implement plotting of polynomials. Again we reuse the name <code>plot</code> which is already used in the <code>PyPlot</code> package, but we specialize it to our <code>MyPoly</code> type:</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-julia"><pre><span></span><span class="k">using</span> <span class="n">PyPlot</span>
<span class="k">function</span> <span class="n">PyPlot</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">p</span><span class="o">::</span><span class="n">MyPoly</span><span class="p">,</span> <span class="n">xlim</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">xx</span> <span class="o">=</span> <span class="n">collect</span><span class="p">(</span><span class="n">range</span><span class="p">(</span><span class="n">xlim</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">xlim</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">length</span><span class="o">=</span><span class="mi">100</span><span class="p">))</span>
    <span class="n">plot</span><span class="p">(</span><span class="n">xx</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="p">(</span><span class="n">xx</span><span class="p">))</span>
    <span class="n">xlabel</span><span class="p">(</span><span class="n">string</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">var</span><span class="p">))</span>
<span class="k">end</span>
</pre></div>

    </div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-julia"><pre><span></span><span class="n">p</span> <span class="o">=</span> <span class="n">MyPoly</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span>
<span class="n">plot</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="n">p</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">



<div class="output_png output_subarea ">
<img src="../images/Structs_And_Objects/Structs_And_Objects_30_0.png"
>
</div>

</div>
</div>
<div class="jb_output_wrapper }}">
<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>MyPoly(1⋅x^5 + 1⋅x^4 - 5⋅x^3 - 5⋅x^2 + 4⋅x + 4)</pre>
</div>

</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Operator-overloading">Operator overloading<a class="anchor-link" href="#Operator-overloading"> </a></h2><p>Operators such as <code>+</code> can also be overloaded for new types, by specializing the function definition in the <code>Base</code> package. Adding polynomials is of course easy, we simply add the coefficients. However we first need to make sure the coefficient vector is long enough to contain the sum:</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-julia"><pre><span></span><span class="k">function</span> <span class="n">Base</span><span class="o">.:+</span><span class="p">(</span><span class="n">p1</span><span class="o">::</span><span class="n">MyPoly</span><span class="p">,</span> <span class="n">p2</span><span class="o">::</span><span class="n">MyPoly</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">p1</span><span class="o">.</span><span class="n">var</span> <span class="o">!=</span> <span class="n">p2</span><span class="o">.</span><span class="n">var</span>
        <span class="n">error</span><span class="p">(</span><span class="s">&quot;Cannot add polynomials of different independent variables.&quot;</span><span class="p">)</span>
    <span class="k">end</span>
    <span class="n">d1</span> <span class="o">=</span> <span class="n">degree</span><span class="p">(</span><span class="n">p1</span><span class="p">)</span>
    <span class="n">d2</span> <span class="o">=</span> <span class="n">degree</span><span class="p">(</span><span class="n">p2</span><span class="p">)</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">d1</span><span class="p">,</span><span class="n">d2</span><span class="p">)</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">eltype</span><span class="p">(</span><span class="n">p1</span><span class="o">.</span><span class="n">c</span><span class="p">),</span> <span class="n">d</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">c</span><span class="p">[</span><span class="k">end</span><span class="o">-</span><span class="n">d1</span><span class="o">:</span><span class="k">end</span><span class="p">]</span> <span class="o">+=</span> <span class="n">p1</span><span class="o">.</span><span class="n">c</span><span class="p">[</span><span class="k">end</span><span class="o">-</span><span class="n">d1</span><span class="o">:</span><span class="k">end</span><span class="p">]</span>
    <span class="n">c</span><span class="p">[</span><span class="k">end</span><span class="o">-</span><span class="n">d2</span><span class="o">:</span><span class="k">end</span><span class="p">]</span> <span class="o">+=</span> <span class="n">p2</span><span class="o">.</span><span class="n">c</span><span class="p">[</span><span class="k">end</span><span class="o">-</span><span class="n">d2</span><span class="o">:</span><span class="k">end</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">MyPoly</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">p1</span><span class="o">.</span><span class="n">var</span><span class="p">)</span>
<span class="k">end</span>
</pre></div>

    </div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-julia"><pre><span></span><span class="n">println</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="n">println</span><span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="n">p</span><span class="p">)</span>
<span class="n">println</span><span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="n">MyPoly</span><span class="p">([</span><span class="mf">1.1</span><span class="p">,</span><span class="mf">2.2</span><span class="p">]))</span>
<span class="n">println</span><span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="n">MyPoly</span><span class="p">([</span><span class="mi">1</span><span class="p">],</span> <span class="sc">&#39;s&#39;</span><span class="p">))</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>MyPoly(1⋅x^5 + 1⋅x^4 - 5⋅x^3 - 5⋅x^2 + 4⋅x + 4)
MyPoly(2⋅x^5 + 2⋅x^4 - 10⋅x^3 - 10⋅x^2 + 8⋅x + 8)
</pre>
</div>
</div>
</div>
<div class="jb_output_wrapper }}">
<div class="output_area">

<div class="output_subarea output_text output_error">
<pre>
InexactError: Int64(Int64, 5.1)

Stacktrace:
 [1] Type at ./float.jl:700 [inlined]
 [2] convert at ./number.jl:7 [inlined]
 [3] setindex! at ./array.jl:769 [inlined]
 [4] setindex!(::Array{Int64,1}, ::Array{Float64,1}, ::UnitRange{Int64}) at ./array.jl:783
 [5] +(::MyPoly, ::MyPoly) at ./In[19]:10
 [6] top-level scope at In[20]:3</pre>
</div>
</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Subtraction is easiest done by overloading the <code>-</code> operator and reusing the implementation of <code>+</code>:</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-julia"><pre><span></span><span class="k">function</span> <span class="n">Base</span><span class="o">.:-</span><span class="p">(</span><span class="n">p1</span><span class="o">::</span><span class="n">MyPoly</span><span class="p">,</span> <span class="n">p2</span><span class="o">::</span><span class="n">MyPoly</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">p1</span> <span class="o">+</span> <span class="n">MyPoly</span><span class="p">(</span><span class="o">-</span><span class="n">p2</span><span class="o">.</span><span class="n">c</span><span class="p">)</span>
<span class="k">end</span>
</pre></div>

    </div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Similarly with scalar multiplication, we overload <code>*</code>. Note that we do not specify the type of the first scalar argument <code>a</code>, it is assumed that it is a regular number (not a <code>MyPoly</code>) object. We also define multiplication in the reverse order, by reusing the same function (since we know that it commutes).</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-julia"><pre><span></span><span class="k">function</span> <span class="n">Base</span><span class="o">.:*</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">p</span><span class="o">::</span><span class="n">MyPoly</span><span class="p">)</span>
    <span class="n">newc</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">p</span><span class="o">.</span><span class="n">c</span>
    <span class="k">return</span> <span class="n">MyPoly</span><span class="p">(</span><span class="n">newc</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">var</span><span class="p">)</span>
<span class="k">end</span>

<span class="k">function</span> <span class="n">Base</span><span class="o">.:*</span><span class="p">(</span><span class="n">p</span><span class="o">::</span><span class="n">MyPoly</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">a</span><span class="o">*</span><span class="n">p</span>
<span class="k">end</span>
</pre></div>

    </div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Using the overloaded operators <code>+</code>, <code>-</code>, and <code>*</code> (for scalars), we can perform many polynomial operations:</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-julia"><pre><span></span><span class="n">p1</span> <span class="o">=</span> <span class="mf">0.4</span><span class="n">p</span>
<span class="n">p2</span> <span class="o">=</span> <span class="n">p1</span> <span class="o">-</span> <span class="o">.</span><span class="mi">3</span><span class="o">*</span><span class="n">MyPoly</span><span class="p">([</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="n">p3</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="n">p2</span> <span class="o">+</span> <span class="n">p</span>
<span class="n">plot</span><span class="o">.</span><span class="p">([</span><span class="n">p1</span><span class="p">,</span><span class="n">p2</span><span class="p">,</span><span class="n">p3</span><span class="p">]);</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">



<div class="output_png output_subarea ">
<img src="../images/Structs_And_Objects/Structs_And_Objects_39_0.png"
>
</div>

</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Generic-programming">Generic programming<a class="anchor-link" href="#Generic-programming"> </a></h2><p>In the examples above we have specialized many functions and operators to work in a specific way for objects of type <code>MyPoly</code>. However, note the advantages of <em>not</em> limiting the type of a variable or function argument to be of a certain type. For example, in the definition of <code>MyPoly</code> we did not specify that the coefficients <code>c</code> should be of e.g. integer or floating point types (in fact our examples used both). This means our functions work perfectly fine also for rational coefficients and arguments:</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-julia"><pre><span></span><span class="n">p</span> <span class="o">=</span> <span class="n">MyPoly</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="o">//</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="o">//</span><span class="mi">7</span><span class="p">])</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>MyPoly(1//1⋅x^2 - 2//3⋅x + 6//7)</pre>
</div>

</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-julia"><pre><span></span><span class="n">p</span><span class="o">.</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">7</span><span class="o">//</span><span class="mi">2</span><span class="p">])</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>2-element Array{Rational{Int64},1}:
   25//21
 1297//84</pre>
</div>

</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>and for complex:</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-julia"><pre><span></span><span class="n">p</span> <span class="o">=</span> <span class="n">MyPoly</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="nb">im</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="nb">im</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>MyPoly((1 + 0im)⋅x^4 + (0 + 1im)⋅x^3 + (-1 + 0im)⋅x^2 + (0 - 1im)⋅x + (1 + 0im))</pre>
</div>

</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-julia"><pre><span></span><span class="n">p</span><span class="o">.</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="nb">im</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span> <span class="o">-</span> <span class="nb">im</span><span class="p">])</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>3-element Array{Complex{Int64},1}:
  1 + 0im
  5 + 0im
 -2 + 1im</pre>
</div>

</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>or for <code>BigFloat</code>:</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-julia"><pre><span></span><span class="n">p</span> <span class="o">=</span> <span class="n">MyPoly</span><span class="p">(</span><span class="n">collect</span><span class="p">(</span><span class="o">-</span><span class="mf">1.5</span><span class="o">:</span><span class="mf">3.5</span><span class="p">))</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>MyPoly(-1.5⋅x^5 - 0.5⋅x^4 + 0.5⋅x^3 + 1.5⋅x^2 + 2.5⋅x + 3.5)</pre>
</div>

</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-julia"><pre><span></span><span class="n">p</span><span class="p">(</span><span class="kt">BigFloat</span><span class="p">(</span><span class="o">-</span><span class="nb">π</span><span class="p">))</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>4.052722682884305251107738095974542912801020079018409933037640550322547603287204e+02</pre>
</div>

</div>
</div>
</div>
</div>

</div>
</div>

 


    </main>
    